## auto

auto - это то же самое что и вывод типа параметра шаблонной функции, как мы рассматривали в первых статьях этого цикла.

Рецепт простой - как только мы видим такое определение auto, то сразу надо нарисовать в голове другое и вспомнить три набора правил выведения типа, когда параметр шаблонной функции специфицирован как указатель или ссылка, как универсальная ссылка или не представляет из себя ни то ни другое.

Так что, для `auto x`:

```cpp
template<typename T>
void likeAutoDeduction(T x) {}
```

Для `const auto x`:

```cpp
template<typename T>
void likeAutoDeduction(const T x) {}
```

Для `const auto & x`

```cpp
template<typename T>
void likeAutoDeduction(const T & x) {}
```

И это все :)...


Пример:

template<typename T>
void func(const std::initializer_list<T> & param) {

}

int main(int argc, const char **argv)  {

  auto a = 1;
  func({1,2,3});
}



auto будет выведено как initializer_list, а func не скомпилируется даже пока не будет создана перегрузка, принимающая initalizer_list, и это, признаться странно. Почему func не может принять const initializer_list по ссылке?

Пишет: "couldn't deduce template parameter ‘T"

https://habr.com/post/330402/

**uniform initialization syntax** - унифицированная инициализация

Так вот **uniform initialization** и initializer_list - это не одно и то же!

initializer_list компилятор создает специальным образом... это помогает избежать шаблонных конструкторов для произвольных классов - решаются проблемы с раздуванем кода, скоростью компиляции ...

Почему для функции T может быть выведено, если указан параметр как initializer_lit<T>, а для конструктора нет?

**Существует порядок**, согласно которому при инициализации сначала ищется конструктор, который принимает initializer_list и только когда он не найден содержимой фигурных скобочек разворачивается и ищется конструктор, который принимает члены этого списка инициализации.

При таком подходе, считает, автор статьи dkozh, если применяется сужающее преобразование при составлении проверочного initializer_list, то такая попытка конструирования могла бы быть отвергнута, однако попытка делается и компилятор выдает ошибку.

Попробовал инициализировать структуру c uniform initalization, в котором именованные члены шли не по порядку или с пропуском, не получилось. Но как? Ведь у auto нет параметров да и нет перед ним конструкции template<typename T>, по которой выводится тот самы Т. 

## decltype

Что нам о нем известно? В него передается выражение и он **в точности** выводит его тип со всеми спецификаторами, не так как это делает вывод типа шаблонной функции. И обычно никаких сюрпризов:
Мейерс приводит кучу примеров, все отрабатывают, никаких сюрпризов...

**Основное применение decltype в с++ 11** - это объявление шаблонов функций, в которых возвращаемый тип зависит от её параметров, когда мы не знаем, что будет и должно быть возвращено. Для выражения этой семантики требуется ключевое слово auto - но это совсем не то, что обычно делает auto. auto говорит о том, что тип будет сказан позже, после определения параметров и на их основании.


```cpp
auto hex(const T & octets) -> HexPrintableOctets<const T &>
{
  return HexPrintableOctets<const T &>(octets);
}
```

однако, можно и с decltype и Скотт приводит пример с оператором [] для вектора bool, который в этом случае возвращает не ссылку, а копию...

```cpp
template<typename ContainerT, typename IndexT>
auto authAndAccess(ContainerT & c, IndexT i) -> decltype(c[i])
{
  doSomething();
  return c[i];
}
```

### c++14

Если мы указали auto перед функцией, но не указали decltype, то тип будет выводиться как в параметре шаблонной функции по тем же правилам. И что нам мешает добавлять свои спецификаторы? Ничего..
Еще мы можем указать decltype(auto) - и это специальная фишка 14 стандарта, тип будет выведен из инструкции return в точности "как есть"...
Можно так писать и при объявлении переменных - правда непонятно, когда это может пригодиться...
Проблема, говорит Скотт, в том, что передавая ссылку на временный объект, мы возвращаем ссылку на его временный же элемент и компилятор это не спалит. Что делать? Используется магия std::forward<Container>(c)[i], а для с++11 инструкции повторяется в decltype после объявления функции. Он то ли вместо возрата ссылки создает копию элемента временного контейнера, когда он является rvalue и возвращает ссылку когда lvalue...

`return std::forward<Container>(c)[i];`

### decltype выводит ссылку когда ему дают нетривиальный lvalue

Скотт уже обращал внимание, на то, что область применения decltype не такая широкая и сводится часто к указанию возвращаемого типа функции.

Если мы обернем переменную `int` в скобки и отдадим `decltype`, то он даст нам тип int &. Вот уж и не знаю что он еще имел ввиду под **lvalue, отличном от имени** :)

Вот пример кода, который эту особенность демонстрирует:

```cpp
  std::cout << "int const i = 0;" << std::endl << "decltype(i) is "
            << boost::typeindex::type_id_with_cvr<decltype(i)>().pretty_name() << std::endl;

  std::cout << "decltype((i)) is "
            << boost::typeindex::type_id_with_cvr<decltype((i))>().pretty_name() << std::endl;
```

```
int const i = 0;
decltype(i) is int const
decltype((i)) is int const&
```

## Кроме всего прочего auto:

1. Оберегает от неиницилизированных переменных, выдает ошибку компиляции.
2. Уберегает от указания длинющего типа итератора или лямбда фукнции - это типовое применение
3. Уберегает от сокращения типа (**type_shortcuts**). Приводится пример std::vector<int>::size_type, который при переходе на 64 разрядную версию windows из 32 разрядного беззнакового становится 64 разрядным.
4. Объявление для lambda auto и std::function - это не одно и то же. Специализации std::function могут потребовать выделения динамической памяти и быть неэффективными, в том числе и для хранения замыканий, это когда в теле лямбды используются ссылки или указатели на переменные локального контекста. Это, кстати, со слов Скотта, может приводить к исключениям выделения динамической памяти. auto обходится выгодней чем boost::bind, Скотт делает ссылку на главу 6, а до нее еще надо дойти.

Вот как выводятся типы для лябд, объявленных при помощи auto и std::function:

```cpp
  auto lambda = ([](){ return 555; });
  std::function<void()> function = ([]{ return 777;});
```

```
Type of lambda declaread as auto: main::{lambda()#1}
Type of lambda declared as std::function: std::function<void ()>
```

_Такой вывод мы получаем при помощи boost::typeindex::type_id_with_crv<decltype(myAutoDeclaredVariable)>().pretty_name()_


5. Это неявное копирование там, где мы даже и подозревать не могли, например, при получении ссылок на объекты коллекции, когда объект коллекции сначала будет неявно скопирован во временный объект, а потом на него будет дана ссылка как в примере с std::unordered_map<std::string, int>, который я кстати не смог скомпилировать. По ссылке на такой временный объект, изменения, которые мы будем делать коснуться только его, этого временного объекта.

Приведу это пример:

```cp
  std::unordered_map<std::string, int> m;

  for (const auto & p: m)
    std::cout << p.second << std::endl;
```
6. Ну и конечно же **auto** обеспечивает лаконичный код

При выводе типа auto необходимо помнить правила, которые мы рассматривали для вывода типов шаблонной функции и помнить оссобенность, которая касается std::initalizer_list.





