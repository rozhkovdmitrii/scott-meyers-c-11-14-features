#auto

**auto** - это то же самое что и вывод типа параметра шаблонной функции, как мы рассматривали в первой статье этого цикла.

**Рецепт простой** - как только мы видим такое определение auto, то сразу надо вспомнить [**три набора правил выведения типа**](https://github.com/rozhkovdmitrii/scott-meyers-c-11-14-features/tree/master/1-type-deduction), когда параметр шаблонной функции специфицирован как указатель или ссылка, как универсальная ссылка или не представляет из себя ни то ни другое.

Так что, для `auto x` мы вспоминаем:

```cpp
template<typename T>
void likeAutoDeduction(T x) {}
```

Для `const auto x`:

```cpp
template<typename T>
void likeAutoDeduction(const T x) {}
```

Для `const auto & x`

```cpp
template<typename T>
void likeAutoDeduction(const T & x) {}
```

## auto и std::initialiation_list 

Когда мы пишем `auto var = {1, 3, 4}`, `var` будет иметь тип `std::initialization_list`. Про фигурные скобочки, **uniform initialization** и **`std::initialization_list<T>`** хорошо написано [**по этой ссылке**](https://habr.com/post/330402/)

**uniform initialization syntax** - унифицированная инициализация и **`initialization_list<T>`** - это не одно и то же, хотя и то и другое осуществляется при помощи синтаксиса фигурных скобочек.

**`std::initializer_list`** компилятор создает специальным образом - это помогает избежать шаблонных конструкторов для произвольных классов - решаются проблемы с раздуванем кода, скоростью компиляции ...

**Существует порядок**, согласно которому при инициализации класса сначала ищется конструктор, который принимает initializer_list и только когда он не найден, содержимое фигурных скобочек разворачивается и ищется конструктор, который принимает члены этого списка инициализации.

> **Примечание**: Если в классе есть два конструктора, один из которых принимает ссылку на **`std::initializer_list<int>**`, а другой два **`double`** и при построении такого класса мы будем инициализировать его {1.0, 0.1} то то будет искаться сначал конструктор **`initializer_list`** и будет найден, но конструирование завершиться ошибкой, так как сужающе преобразование в этом случае будет запрещено. Это знание может быть полезным.
```cpp
class A {
public:
  A(const std::initializer_list<int> & list): _value("A from initializer list") {}
  A(const double p1, const double p2): _value("constructed from 2 double")  {}
}
```

```
error: narrowing conversion of ‘1.0e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]
```

> **Примечание**: Попробовал инициализировать структуру c uniform initalization, в котором именованные члены шли не по порядку или с пропуском, не получилось. `A a = {.field1 = 1, .field3 = 2, field2 = 2}`. Как я понял инициализировать надо все сразу и по порядку.

**Выводы по пункту** :

- когда мы пишем auto `a = {1, 2, 3}` - это `**std::initialization_list<int>**`
- когда мы пишем `A a = {1, 2, 3}` - он будет искать в первую очередь конструктор принимающий `**const std::initialization_list<int> &**` и **надо быть внимательным**.

# decltype

Что нам о нем известно? В него передается выражение и он **в точности** выводит его тип со всеми спецификаторами, не так как это делает вывод типа шаблонной функции. И обычно никаких сюрпризов - Мейерс приводит кучу примеров, все отрабатывают.

**Основное применение decltype в с++ 11**, пишет Скотт, это объявление шаблонов функций, в которых возвращаемый тип зависит от её параметров, когда мы не знаем, что будет и должно быть возвращено. Для выражения этой семантики требуется ключевое слово auto на месте возвращаемого типа (далее **возвращаемый auto**) и это совсем не то, что обычно делает auto. Возвращаемый **auto** говорит о том, что тип будет сказан позже, после определения параметров и на их основании.

#### Мой пример с auto

```cpp
auto hex(const T & octets) -> HexPrintableOctets<const T &>
{
  return HexPrintableOctets<const T &>(octets);
}
```

однако, можно и с **decltype** и Скотт приводит пример с оператором [] для вектора **bool**, который в этом случае возвращает не ссылку, а копию...

#### Пример Скотта с auto и decltype

```cpp
template<typename ContainerT, typename IndexT>
auto authAndAccess(ContainerT & c, IndexT i) -> decltype(c[i])
{
  doSomething();
  return c[i];
}
```

### c++14

Если мы указываем **возвращаемый auto**, но не указываем **decltype**, то тип будет выводиться как в параметре шаблонной функции по тем же правилам. И что нам мешает добавлять свои спецификаторы? Ничего..
Еще мы можем указать вместо возвращаемого **auto** **decltype(auto)** - и это специальная фишка 14 стандарта, тип будет выведен из инструкции return в точности "как есть", так как это бы делалось если бы мы подаставили возвращаемое значение в **decltype**

Можно так писать и при объявлении переменных - правда непонятно, когда это может пригодиться...

Проблемы случаются тогда, говорит Скотт, когда передавая ссылку на временный объект, мы возвращаем ссылку на его временный же элемент и компилятор это не палит. Что делать? Используется магия **`std::forward<Container>(c)[i]`**, а для с++11 инструкция повторяется в decltype после объявления функции. Он вместо возрата ссылки создает копию элемента временного контейнера, когда он является rvalue и возвращает ссылку когда lvalue...

`return std::forward<Container>(c)[i];`

### decltype выводит ссылку когда ему дают нетривиальный lvalue

Скотт уже обращал внимание, на то, что область применения decltype не такая широкая и сводится часто к указанию возвращаемого типа функции.

Если мы обернем переменную `int` в скобки и отдадим `decltype`, то он даст нам тип int &. 
****
Вот пример кода, который эту особенность демонстрирует:

```cpp
  std::cout << "int const i = 0;" << std::endl << "decltype(i) is "
            << boost::typeindex::type_id_with_cvr<decltype(i)>().pretty_name() << std::endl;

  std::cout << "decltype((i)) is "
            << boost::typeindex::type_id_with_cvr<decltype((i))>().pretty_name() << std::endl;
```

```
int const i = 0;
decltype(i) is int const
decltype((i)) is int const&
```

# снова auto

**auto, кроме всего прочего, уберегает нас:**

1. Оберегает от неиницилизированных переменных, выдает ошибку компиляции.
2. Уберегает от указания длинющего типа итератора или лямбда фукнции - это типовое применение
3. Уберегает от сокращения типа (**type_shortcuts**). Приводится пример std::vector<int>::size_type, который при переходе на 64 разрядную версию windows из 32 разрядного беззнакового становится 64 разрядным.
4. Объявление для lambda auto и std::function - это не одно и то же. Специализации std::function могут потребовать выделения динамической памяти и быть неэффективными, в том числе и для хранения замыканий, это когда в теле лямбды используются ссылки или указатели на переменные локального контекста. Это, кстати, со слов Скотта, может приводить к исключениям выделения динамической памяти. auto обходится выгодней чем boost::bind, Скотт делает ссылку на главу 6, а до нее еще надо дойти.

Вот как выводятся типы для лямбд, объявленных при помощи auto и std::function:

```cpp
  auto lambda = ([](){ return 555; });
  std::function<void()> function = ([]{ return 777;});
```

```
Type of lambda declaread as auto: main::{lambda()#1}
Type of lambda declared as std::function: std::function<void ()>
```

5. От неявного копирвоания там, где мы даже и подозревать не могли, например, при получении ссылок на объекты коллекции, когда объект коллекции сначала будет неявно скопирован во временный объект, а потом на него будет дана ссылка как в примере с std::unordered_map<std::string, int>, который я кстати не смог скомпилировать. По ссылке на такой временный объект, изменения, которые мы будем делать коснуться только его, этого временного объекта.

Приведу пример:

```cp
  std::unordered_map<std::string, int> m;

  for (const auto & p: m)
    std::cout << p.second << std::endl;
```
6. Ну и конечно же **auto** обеспечивает лаконичный код








