### Добрый день, дорогой читатель!

Эта статья - вторая в цикле статей-конспектов, которые я буду писать в ходе прочтения бестселлера Скотта Мейерса "Эффективный и современный c++". Каждой из таких статей будет соответствовать отдельная директория в **[специально заведенном на github.com проекте](https://github.com/rozhkovdmitrii/scott-meyers-c-11-14-features)** с живыми примерами использования того, что мы с Вами сегодня читаем.
<cut />

Эта статья дополняет [правила выведения типа из предыдущей статьи](https://habr.com/post/414233/) и рассматривает отдельные аспекты вывода типа шаблона для аргументов, являющихся массивом и функцией.

# Вывод типа шаблона для массива

Есть такое свойство у компилятора c++, что объявленный массив всегда, при передаче в шаблонную функцию с параметром, объявленным **не как ссылка** всегда преобразуется к указателю на хранимый тип и обратно, если параметр объявлен как ссылка, то такое преобразование не производится.

### Шаблонные функции:

Для начала, я приведу код шаблонных функций, которые выводят заветные типы, а затем и сам процесс выведения:

```cpp
template<typename T>
void paramDeductInfo(T param, const char *initType)
{
  std::cout << initType << " -> (T param) -> "
            << type_id_with_cvr<T>().pretty_name() << std::endl;
};

template<typename T>
void refParamDeductInfo(T &param, const char *initType)
{
  std::cout << initType << " -> (T &param) -> "
            << type_id_with_cvr<T>().pretty_name()
            << std::endl;
};
```
### Вывод типа:

```cpp
cli::printCaption("TYPE DEDUCTION FOR ARRAY OF CHAR");

char charSeq[] = "Hi everyone!";
paramDeductInfo(charSeq, "char []");
refParamDeductInfo(charSeq, "char []");

cli::printCaption("TYPE DEDUCTION FOR ARRAY OF INT");
int intSeq[] = {1, 2, 3};
paramDeductInfo(intSeq, "int []");
refParamDeductInfo(intSeq, "int []");

cli::printCaption("TYPE DEDUCTION FOR ARRAY OF CLASS A");
class A {
} const classASeq[] = {A(), A(), A()};

paramDeductInfo(classASeq, "class A[]");
refParamDeductInfo(classASeq, "class A[]");
```

Следующий псевдокод, отражает вывод в консоль этих инструкций:

```
************************************************************************************************************************
TYPE DEDUCTION FOR ARRAY OF CHAR
************************************************************************************************************************

char [] -> (T param) -> char*
char [] -> (T &param) -> char [13]

************************************************************************************************************************
TYPE DEDUCTION FOR ARRAY OF INT
************************************************************************************************************************

int [] -> (T param) -> int*
int [] -> (T &param) -> int [3]

************************************************************************************************************************
TYPE DEDUCTION FOR ARRAY OF CLASS A
************************************************************************************************************************

class A[] -> (T param) -> main::A const*
class A[] -> (T &param) -> main::A const [3]
```

## Пример 1 - анализ длины массива compile-time

Более того, выводимый тип массива хранит информацию о его размере, что можно использовать в шаблонной функции для манипуляции с размером массива во время компиляции или для генерации более производительного кода.

Я использовал эту возможность в функции **printCaption** чтобы ограничить длину отображаемого в командную строку заголовка во время компиляции. Мелочь, а приятно.

```cpp
namespace cli
{
template<typename T, std::size_t N>
constexpr void printCaption(T (&capValue)[N])
{
  static_assert(N <= 121, "caption length should be less than 120");
  std::cout << std::endl <<
            "*******************************************************************************"
            << std::endl << capValue << std::endl <<
            "*******************************************************************************"
            << std::endl << std::endl;
};
}
```
Давайте проверим, будет ли ошибка если мы введем заведомо не соответствующий требованиям заголовок.

```cpp
cli::printCaption("123456789 123456789 123456789 123456789 123456789 123456789 123456789"
                  "123456789 123456789 123456789 123456789 123456789 !");
```
И вот вам, пожалуйста, ну не замечательно ли это?

```
/...sources/cli.h:12:3: error: static assertion failed: caption length should be less than 120
   static_assert(N <= 120, "caption length should be less than 120");
   ^~~~~~~~~~~~~
```

## Пример 2 - foreach на массиве на памяти

Думаю, вот еще такой подход может показаться полезным, если у нас есть в compile-time размер массива, почему бы его не использовать для организации цикла на таком массиве?

```cpp
template<typename T, size_t N, typename F>
void forEachOnAnArray(T (&inmemArray)[N], F &callback) {
  for (int i = 0; i < N; ++i)
    callback(inmemArray[i]);
};
```
#### Использование этой функции выглядит следующим образом:

```cpp
  auto printInt = [](int value) { std::cout << " " << value; };
  forEachOnAnArray(intSeq, printInt);
```

В общем, использование этой возможности отнюдь не ограничивается вытаскиванием размера массива.


## Выведение типа для функции
